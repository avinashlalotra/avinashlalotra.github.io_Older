## üöÄ Hello World from Scratch: Bringing Up a RISC-V Core from RTL to C
Welcome! If you're wondering how to get started with hardware design, you've landed in the right place.

This guide takes you from zero to running C programs on an FPGA, using an open-source RISC-V core. Whether you're a student, hobbyist, or engineer looking to understand the full hardware-software bring-up process, this post will walk you through the essentials ‚Äî from writing Verilog to printing "Hello, World" on your console.

# üéØ Goals
- [Boot an FPGA with a CPU and memory](#step1)

- Add peripherals like UART, GPIO, LEDs, or your own custom digital logic

- Run C and assembly programs on the system

- Finally... print "Hello, World" to the console!

# üß∞ Requirements
- Any FPGA board

- A system with Vivado installed

- Basic familiarity with Verilog, C, and assembly (If you're new to these ‚Äî no worries! This guide is beginner-friendly.)

Preferably a Linux system (Windows can work too, with some extra setup)

# üõ†Ô∏è Steps Overview
- Set up the PicoRV32 core and connect peripherals

- Install the RISC-V toolchain (riscv-gcc, etc.)

- Write, compile, and load C programs into memory

- Watch your console light up with:
```bash
Hello, World
```



## üß™ <a id="step1"></a>Step 1: Set Up the PicoRV32 Core
We'll be using the open-source PicoRV32 core, which implements the RV32IMC instruction set ‚Äî meaning it supports 32-bit integer operations, multiplication, and compressed instructions. It doesn't support floating point operations, which is fine for our minimal setup.

üîß Clone the repository:
```bash
git clone https://github.com/YosysHQ/picorv32.git
```

üõ† Add PicoRV32 to Your Vivado Project
Open Vivado and create a new project.

Add picorv32.v to your design sources.

Modify picorv32.v as follows:

Find this block:

```verilog
// `define PICORV32_REGS picorv32_regs
```
Uncomment the line so it becomes:

```verilog
`define PICORV32_REGS picorv32_regs
This enables using the register file in a separate module.
```
üß† Add Memory Module (memory.v)
Create a new Verilog file called memory.v with the following content:

```verilog
module memory #(
    parameter integer WORDS = 256
) (
    input clk,
    input [3:0] wen,
    input [21:0] addr,
    input [31:0] wdata,
    output reg [31:0] rdata
);
    reg [31:0] mem [0:WORDS-1];

    initial begin
        $readmemh("memory.mem", mem);
    end

    always @(posedge clk) begin
        rdata <= mem[addr];
        if (wen[0]) mem[addr][ 7: 0] <= wdata[ 7: 0];
        if (wen[1]) mem[addr][15: 8] <= wdata[15: 8];
        if (wen[2]) mem[addr][23:16] <= wdata[23:16];
        if (wen[3]) mem[addr][31:24] <= wdata[31:24];
    end
endmodule
```
Each word is 4 bytes (32 bits).

Memory is initialized from a file called memory.mem, which will be generated by the compiler later.

üß± Create Top-Level Module (top.v)
This module connects the CPU and memory using PicoRV32‚Äôs native memory interface:

```verilog
module top (
    input clk,
    input resetn
);
    parameter [0:0] BARREL_SHIFTER = 1;
    parameter [0:0] ENABLE_MUL = 1;
    parameter [0:0] ENABLE_DIV = 1;
    parameter [0:0] ENABLE_FAST_MUL = 0;
    parameter [0:0] ENABLE_COMPRESSED = 1;
    parameter [0:0] ENABLE_COUNTERS = 1;
    parameter [0:0] ENABLE_IRQ_QREGS = 0;

    parameter integer MEM_WORDS = 256;
    parameter [31:0] STACKADDR = (4 * MEM_WORDS);
    parameter [31:0] PROGADDR_RESET = 32'h0010_0000;
    parameter [31:0] PROGADDR_IRQ = 32'h0000_0000;

    wire mem_valid, mem_instr, mem_ready;
    wire [31:0] mem_addr, mem_wdata, mem_rdata;
    wire [3:0] mem_wstrb;

    assign mem_ready = mem_valid;

    picorv32 #(
        .STACKADDR(STACKADDR),
        .PROGADDR_RESET(PROGADDR_RESET),
        .PROGADDR_IRQ(PROGADDR_IRQ),
        .BARREL_SHIFTER(BARREL_SHIFTER),
        .COMPRESSED_ISA(ENABLE_COMPRESSED),
        .ENABLE_COUNTERS(ENABLE_COUNTERS),
        .ENABLE_MUL(ENABLE_MUL),
        .ENABLE_DIV(ENABLE_DIV),
        .ENABLE_FAST_MUL(ENABLE_FAST_MUL),
        .ENABLE_IRQ(1),
        .ENABLE_IRQ_QREGS(ENABLE_IRQ_QREGS)
    ) cpu (
        .clk(clk),
        .resetn(resetn),
        .mem_valid(mem_valid),
        .mem_instr(mem_instr),
        .mem_ready(mem_ready),
        .mem_addr(mem_addr),
        .mem_wdata(mem_wdata),
        .mem_wstrb(mem_wstrb),
        .mem_rdata(mem_rdata)
    );

    memory #(
        .WORDS(MEM_WORDS)
    ) ram (
        .clk(clk),
        .wen((mem_valid && mem_addr < 4 * MEM_WORDS) ? mem_wstrb : 4'b0),
        .addr(mem_addr[23:2]),
        .wdata(mem_wdata),
        .rdata(mem_rdata)
    );
endmodule
```
üì¶ Prepare Memory Contents
Create a memory.mem file with dummy instructions like this:

```
00000013
00000013
00000013
00000013
```
Each line is a 32-bit instruction in hex ‚Äî here, 00000013 represents a NOP (ADDI x0, x0, 0).

This will help you verify the system is fetching and executing instructions.

üß™ Create a Testbench (top_tb.v)
```verilog
`timescale 1ns / 1ps

module top_tb;

    reg clk;
    reg resetn;

    top uut (
        .clk(clk),
        .resetn(resetn)
    );

    initial clk = 0;
    always #5 clk = ~clk; // 100 MHz clock

    initial begin
        $display("Starting simulation...");

        resetn = 0;
        #100;
        resetn = 1;

        $display("Reset deasserted. Running...");

        #5000;

        $display("Simulation finished.");
        $finish;
    end

endmodule
```
‚úÖ What to Expect
After you run the simulation:

Check the Program Counter (PC) inside the picorv32 instance.

If it increments over time, your system is booting and executing the NOPs.

If it stays stuck, recheck clock, reset, or memory connections.
